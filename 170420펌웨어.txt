170420 - Interrupt

정확하게 하자 ! (숙제 하나 나갈것)

인터럽트 - 실행중 예외 발생시 실행을 중단, 예외처리를 한 후, 중단되었던 실행을 계속 처리함.

인터럽트를 쓴다는것 ? - 내부적인 일을 하고 있는 동안에도 외부적인 사건에 반응할수 있음


프로그램 구조를 생각해보자.

A. 1초에 한번 LED 깜빡이다가, 스위치 입력이 있으면 꺼져있게 하고 싶다.

B. 1초에 한번 LED 깜빡이다가, 스위치 입력이 있으면 켜져깄게 하고 싶다. 그러나 켜져 있는 상태에서 다시 스위치 누르면 LED도 다시 깜빡이게 하고싶다.

C. 1초에 한번 LED 깜빡이게 하다가, 스위치 입력이 있으면 매번 2배씩 빠르게 깜빡이게 하고싶다.


인터럽트 순서

1. 인터럽트 요청 신호 발생 -> 레지스터에 등록
2. 실행중인 프로그램 중단
3. 중단한 프로그램 상태 보존 (Context)
4. 인터럽트 처리 루틴 실행(ISR:Interrupt Service Routine)
5. 인터럽트 서비스 루틴 실행 -> 직접 제작할 예정
6. 중단되었던 프로그램의 상태 복구
7. 중단된 프로그램 재실행

인터럽트 벡터 : 서비스 분기 명령어들이 지정된 영역, 인터럽트 발생시 서비스가 특정장소로 이동하도록 번지 지정

할 일: 인터럽트 벡터 만들기, 인터럽트 관련 레지스터 등록하기, 나머지는 시스템이 알아서


인터럽트 관련 레지스터
ICCR(DIM을 제어, DIM bit가 Set 일때, CPU에서 인터럽트 사용 가능하도록 idle mode를 저지)
ICMR(인터럽트에 대한 마스크 비트, 해당 비트 SET 일시, 인터럽트 발생시 IRQ나 FQ로 보냄)
- GPIO #0,#1 을 제외한 나머지는 GPIO_X 로 퉁침.
- OST_0
ICLR(Pending 인터럽트가 발생시 fiq, irq로 발생할지 제어)
- EDGE로 받음. (OST_O,GPIO_X), 0일때 IRQ모드

void $ISR이름(unsigned long a);
void init_intr(void){
	ICCR = 0x1; // CPU에서 인터럽트 처리할수 있게 해줌.
	ICLR &= (0 << 10); // IRQ 발생 (수정 필요)
	ICMR |= (1 << 10); // MASK BIT SETTING
}


except.c	-> irqtbl[10] = $ISR이름;
		-> extern int $ISR이름(매개변수);

-----------------------------------------------------------------------

돌리는것은 그대로 끄는것은 인터럽트루틴에서.
제출은 하지않지만 화요일까지 실험을 했으면좋겠다
-> 누르면 1초간 꺼지는것 1초가 지나면 다시 깜빡인다

//-- 인터럽트 벡터 --//
/* 
	GEDR로 값을 읽은후에 값이 남아 있으면 
    그 값으로 인해 계속 ISR 로 가게 됨.
    따라서 한번 엣지를 읽고 나면 GEDR 을 초기화 하여
    다시 엣지를 받을 준비를 해야 함.
    
    ISR은 최소화 합시다
    
    역전현상 : 우선순위가 낮은 프로세스에 높은 프로세스가 지장받음.
*/



