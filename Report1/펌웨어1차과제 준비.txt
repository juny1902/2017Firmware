목표 :

최적의 LED제어, 스위치 입력 함수를 만들자

서론 :

임베디드 시스템에서의 효율적인 프로그램이란 무엇일까 ?

임베디드는 범용 컴퓨터와 다르게 제한된 자원 속에서 안정적으로 동작하는것을 목표로 두고있다.

따라서 우리는 메모리 공간을 절약함으로써 제한된 자원을 효율적으로 사용하고.

불필요한 연산을 피해 코드를 최적화 함으로써 프로그램이 오랜시간 안정적으로 동작하게 해야한다.

그러나 이렇게 메모리 공간을 절약하며 안정적으로 동작하게 하는것은 어려운 일이고 서로 상충되는 경우가 다반사이다.

따라서 우리는 두가지 요소를 환경과 용도에 맞게 적절히 절충해가며 사용자가 오랜기간 만족할 수 있는 프로그램을 제작해야한다.

이번 과제에선, 위와 같은 목표를 달성하기 위한 첫 걸음인 LED 제어와 스위치 입력 받기에 대한 함수를 제작해 보았다. 

2. 헤더 파일과 소스 파일

[user.h]

1.GPIO의 Set,Clear,Direction,Load 레지스터의 주소를 정의하였다.

2.LED와 스위치의 상태를 나타낼 이름을 정의하였다.

3.3개의 함수 INIT_DEVICE(void), IS_SW_PRESSED(void), LED_Control(int, int) 의 원형을 정의하였다.

[user.c]

1.위에서 정의한 함수의 원형을 user.c 에서 구현하였다.

2.구현한 함수


2.1 INIT_DEVICE(void)

[함수의 구현 의도]

GPIO의 입/출력 방향을 정하고 LED의 초기 상태를 설정하는 함수이다.

GPDR에 오직 필요한 비트만 마스킹 하기위해 '|=' 연산을 수행하였다.

GPSR(General Purpose Set Register) 에서 LED에 해당하는 비트에 1 을 마스킹 함으로써 LED를 소등한다.


2.2 int IS_SW_PRESSED(void)

[함수의 구현 의도]

GPLR의 특정 비트를 검출하고 그 값을 비교함으로써 어떤 스위치가 눌렸는지 그 값을 상수로 반환하는 함수이다.

해당 비트의 값이 0 인지 판별하는 ((GPLR1 & 0x00200000) == 0) 구문을 매크로 상수로 Define 한다.

단, 본 레포트에서는 논리 비교를 최소화 하여 불필요한 반복적인 비교연산을 피하기 위해 

user.h 에서

#define SW1_STAT (~((GPLR1) & (0x00200000)))

형태로 본 함수의 조건문을 간략화 하였다.

이 경우, 스위치1 이 눌리면 1, 눌리지 않으면 0의 값을 가지게 된다.

컴파일시 매크로의 오류를 방지하기 위해 각 인자, 연산 단위를 괄호로 명확히 구분하였다. 


[함수의 구현]

Debounce 를 위해 1000[word] 만큼의 delay 를 준다.

우선 스위치1 과 스위치2 가 모두 '참' 인지 판별하여 양측 스위치가 동시에 눌렸는지 확인한다.

이 경우 이 함수는 'BOTH', 즉 상수 '3' 를 반환한다.

그렇지 않다면, 스위치1 또는 스위치2 가 눌렸는지 확인하고 각 조건에 맞는 값(1 또는 2)을 반환한다.

어느것도 눌리지 않았다면 'NP', 즉 상수 '0' 을 반환한다.


2.3 LED_Control(int CTL, int N)

[함수의 구현 의도]

LED를 제어하고자 하는 부분마다 GPCR1 = 번지; 와 같은 DMA(Direct Memory Access) 방식으로 코딩한다면.

주석문을 남겨둔다 해도 가독성이 떨어질 뿐 아니라, 만일 LED를 제어하는 주소를 변경해야할 경우 해당하는 부분일 하나하나 수정해야 하는 단점이 있따.

이와 같은 단점을 보완하기 위해 LED_Control(제어변수, LED번호) 함수를 구현하여 보다 쉽게 LED를 제어하고 수정이 용이하도록 하였다.

[함수의 구현]

우선 LED를 어떻게 제어할 것인지 판단한다. 매개변수 CTL 에는 user.h 에서 정의한 BLK, ON, OFF 의 값이 입력된다.

switch(CTL) 문에서 CTL 매개변수는 LED를 깜박일것인지, 켤것인지, 끌것인지를 먼저 판별한다.

만일 CTL == BLK 일 경우, 양측 LED 를 1회 점멸하는 동작을 한다.

만일 CTL == ON 일 경우, N에서 지정한 LED만 켠다. 이 때, N=1 이거나 N=2 이면 한쪽 LED만 점등하게 되는데 이 경우 반대편 LED는 소등되도록 구현하였다.

만일 CTL == OFF 일 경우, ON 동작과 다르게 지정한 LED만 소등한다. (반대편 LED가 점등되지는 않는다.)


